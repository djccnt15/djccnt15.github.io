---
published: true
layout: post

title: '[SQL] 05. SQL 기본 - 1'
description: >
    SQL 기본: 관계형 데이터베이스, DDL, DML, TCL
hide_description: false
image:
    path: /assets/img/posts/sql_05.png
related_posts:
    - _posts/programming/2022-08-08-sql_04.md
    - _posts/programming/2022-08-13-sql_06.md

categories:
    - Programming
tags:
    - programming
    - SQL
---
* toc
{:toc}

## 1. 관계형 데이터베이스

### 1-1. 데이터베이스

일반적으로 **데이터베이스(Database, DB)**는 특정 기업이나 조직 또는 개인이 필요에 의해 데이터를 일정한 형태로 저장해 놓은 것을 의미한다.  

데이터베이스를 관리하기 위한 소프트웨어를 **DBMS(Database Management System)**라 한다. DBMS는 효율적인 데이터의 관리, 데이터의 손상 방지, 필요 시 데이터 복구 등의 기능을 제공한다.  

### 1-2. SQL

**SQL(Structured Query Language)**은 관계형 데이터베이스에서 데이터 정의/조작/제어를 하기 위해 사용하는 언어이다. SQL의 종류는 다음과 같다.  

- [DDL](#2-ddl): `CREATE`, `ALTER`, `DROP`, `RENAME`
- [DML](#3-dml): `SELECT`, `INSERT`, `UPDATE`, `DELETE`
- DCL: `GRANT`, `REVOKE`
- [TCL](#4-tcl): `COMMIT`, `ROLLBACK`

### 1-3. 테이블

**테이블(TABLE)**은 데이터를 저장하는 객체(Object)로, 관계형 데이터베이스의 기본 단위이다. 테이블의 열을 칼럼(Column), 가로 방향을 행(Row)이라고 하고, 열과 행이 겹치는 하나의 공간을 필드(Field)라고 한다.  

테이블을 분할하여 데이터의 불필요한 중복을 줄이는 것을 [정규화(Normalization)](/programming/sql_03/#2-정규화)라고 한다. [정규화(Normalization)](/programming/sql_03/#2-정규화)는 데이터의 정합성 확보 및 데이터 입력/수정/삭제시 발생할 수 있는 이상현상(Anomaly)을 방지를 위한 프로세스이다.  

테이블의 각 행을 한 가지 의미로 특정할 수 있는 한 개 이상의 칼럼을 **기본키(Primary Key, PK)**라고 하며, 다른 테이블의 기본 키로 사용되면서 테이블과의 관계를 연결하는 역할을 하는 칼럼을 **외부키(Foreign Key, FK)**라고 한다.  

### 1-4. ERD

**ERD(Entity Relationship Diagram)**은 테이블 간의 관계를 표현하는 도식으로, 관계의 의미를 직관적으로 표현해준다는 장점이 있다.  

## 2. DDL

**DDL(Data Definition Language)**은 데이터 정의어로 테이블을 생성하고 생성된 테이블의 구조를 변경하는 명령어들이다. 명령어에 따른 작업이 **즉시 완료(AUTO COMMIT)**된다.  

### 2-1. CREATE TABLE

테이블 생성 시에는 테이블에 입력될 데이터를 정의하고, 정의한 데이터의 유형을 선언한다.  

```sql
CREATE TABLE [TD_NAME] ([COL_NAME_1] [DATATYPE] [DEFAULT_VALUE], [COL_NAME_2] [DATATYPE] [DEFAULT_VALUE]);
```

테이블 생성 시의 유의점은 다음과 같다.  

- 테이블명으로 객체를 의미할 수 있는 이름 사용. 가능한 단수형
- 테이블명의 중복 금지, 테이블 내의 칼럼명 중복 금지
- 테이블의 각 칼럼들은 괄호`()`로 묶어 지정
- 각 칼럼들은 콤마`,`로 구분. 테이블 생성문의 끝은 반드시 세미콜론`;`
- 칼럼의 데이터 유형 반드시 지정
- 테이블명과 칼럼명은 반드시 문자로 시작. A-Z, a-z, 0-9, _, $, # 문자만 허용

#### 데이터 유형

특정 칼럼을 정의할 때 선언한 **데이터 유형(Data Type)**은 그 칼럼이 받아들일 수 있는 자료의 유형을 규정한다. 기본적인 데이터 유형들은 다음과 같다.  

- `CHARACTER(s)`
    - 고정 길이 문자열 정보. 크기(s)가 고정되어 있어 입력값이 s 보다 작으면 빈 공간으로 채워서 저장함.
    - 'AA' = 'AA '
- `VARCHAR(s)`
    - 가변 길이 문자열 정보. 할당된 변수값의 바이트만 적용.
    - 'AA' != 'AA '
- `NUMERIC`
    - 정수, 실수 등 숫자 정보
- `DATETIME`
    - 날짜 및 시각 정보

#### 제약조건

특정 칼럼에 적용하는 **제약조건(constraint)**의 종류들은 다음과 같다.  

- `PRIMARY KEY`(기본키)
    - 하나의 테이블에 하나의 기본키 제약만 정의할 수 있음
    - 기본키 제약 = 고유키 제약 & NOT NULL
- `UNIQUE KEY`(고유키)
    - 기본키와 비슷하나 NULL은 제약 대상이 아님
- `NOT NULL`
    - NULL 값 입력 금지
- `CHECK`
    - TRUE/FALSE를 반환하는 논리식을 통해 입력값 제한
- `FOREIGN KEY`(외래키)
    - 테이블 간의 관계 정의를 위한 외래키 지정

❗ NULL과 공백은 다르다
{:.note title='attention'}

### 2-2. ALTER TABLE

테이블 구조 변경을 위한 명령어들로, 세부 명령어들은 다음과 같다.  

- `ADD`

기존 테이블에 칼럼을 추가하는 명령어로, 추가된 칼럼은 테이블의 마지막 칼럼이 된다.  

```sql
ALTER TABLE [TD_NAME] ADD [COL_NAME] [DATATYPE];
```

- `DROP COLUMN`

테이블에서 칼럼을 삭제하는 명령어로, 한 번에 하나의 칼럼만 삭제 가능하며 칼럼 삭제 후 최소 하나 이상의 칼럼이 테이블에 존재해야 한다. 삭제된 칼럼은 복구가 불가능하다.  

```sql
ALTER TABLE [TD_NAME] DROP COLUMN [COL_NAME];
```

- `MODIFY COLUMN`

테이블의 칼럼에 대한 정의를 변경하는 명령어로, 데이터 유형, 디폴트 값, 제약조건 등을 변경할 수 있다. Oracle과 MSSQL이 조금 다르다.  

```sql
-- Oracle
ALTER TABLE [TD_NAME] MODIFY ([COL_NAME_1] [DATATYPE] [DEFAULT_VALUE] NOT NULL, [COL_NAME_2] [DATATYPE] …);

-- MSSQL
ALTER TABLE [TD_NAME] ALTER ([COL_NAME_1] [DATATYPE] [DEFAULT_VALUE] NOT NULL, [COL_NAME_2] [DATATYPE] …);
```

- `RENAME COLUMN`

칼럼명을 변경하기 위해 사용하는 명령어로, 일부 DBMS에서는 칼럼명 변경 시 관계된 제약조건도 자동으로 변경된다.  

```sql
ALTER TABLE [TD_NAME] RENAME COLUMN [OLD_NAME] TO [NEW_NAME];
```

- `DROP CONSTRAINT`

제약조건을 삭제한다.  

```sql
ALTER TABLE [TD_NAME] DROP CONSTRAINT [CON_NAME];
```

- `ADD CONSTRAINT`

제약조건을 추가한다.  

```sql
ALTER TABLE [TD_NAME] ADD CONSTRAINT [CON_NAME] [CON_TYPE] (COL_LIST);
```

### 2-3. RENAME TABLE

테이블의 이름을 변경한다.  

```sql
RENAME [OLD_NAME] TO [NEW_NAME];
```

### 2-4. DROP TABLE

테이블을 삭제한다.  

```sql
DROP TABLE [TD_NAME];
```

### 2-5. TRUNCATE TABLE

해당 테이블에 들어있는 모든 행을 제거하고 저장공간을 재사용 가능하도록 한다. 정상적인 복구가 불가능하므로 주의해야 한다.  

```sql
TRUNCATE TABLE [TD_NAME];
```

## 3. DML

**DML(Data Manipulation Language)**은 데이터 조작어로 테이블을 조작(자료 입력, 수정, 삭제, 조회)을 위한 명령어들이다.  

DDL 명령어들과는 달리 명령어가 테이블에 반영되려면 `COMMIT` 명령어를 통해 트랜잭션을 종료해야 한다. 다만 DML 명령어 이후에 DDL 명령어가 입력되면 AUTO COMMIT으로 인해 같이 `COMMIT` 된다.  

### 3-1. INSERT

테이블에 데이터를 입력하는 명령어로, 문자열을 입력해야할 경우 입력값에 `''`으로 표시한다.  

```sql
-- insert value into called column
INSERT INTO [TD_NAME] (COL_LIST) VALUES (VAL_LIST);

-- insert value into all column
INSERT INTO [TD_NAME] VALUES (VAL_LIST);
```

### 3-2. UPDATE

입력된 정보를 수정한다.  

```sql
UPDATE [TD_NAME] SET [COL_NAME] = [NEW_VALUE];
```

### 3-3. DELETE

데이터를 삭제한다.  

```sql
DELETE FROM [TD_NAME];
```

### 3-4. SELECT

데이터를 조회한다. 데이터의 변형 없이 조회만 하기 때문에 `ROLLBACK`의 대상이 되지 않는다.  

```sql
-- returns all row
SELECT (COL_LIST) AS [ALIAS] FROM [TD_NAME];

-- return unique values
SELECT DISTINCT [COL_NAME] AS [ALIAS] FROM [TD_NAME];
```

`ALIAS` 옵션 사용 시 공백을 넣으려면 `""`으로 묶어줘야 한다.  

### 3-5. 연산자

- 산술 연산자

`(), *, /, +, -`를 이용해서 산술 연산 된 결과를 조회할 수 있다.  

- 합성 연산자

문자와 문자를 연결하는 **합성(CONCATENATION)** 연산을 통해 유용한 결과를 출력할 수 있다.  

```sql
-- Oracle
SELECT [COL_NAME] || 'CHAR' FROM [TD_NAME];

-- MSSQL
SELECT [COL_NAME] + 'CHAR' FROM [TD_NAME];
```

## 4. TCL

**TCL(Transaction Control Language)**은 트랜잭션 제어어로 트랜잭션을 제어하기 위한 명령어들이다.  

### 4-1. 트랜잭션 개요

트랜잭션은 데이터베이스의 논리적 연산단위를 말하며, 분리될 수 없는 한 개 이상의 데이터베이스 조작을 가리킨다. 트랜잭션의 특성은 다음과 같다.  

- 원자성(atomicity)
    - 트랜잭션에서 정의된 연산들은 모두 성공하거나 전혀 실행되지 않아야 함
    - 원자성의 확보를 위해 잠금(LOCKING)이 적용됨
- 일관성(consistency)
    - 트랜잭션이 실행되기 전의 데이터베이스 내용이 잘못 되어 있지 않다면 트랜잭션이 실행된 이후에도 데이터베이스의 내용에 잘못이 있으면 안 됨
- 고립성(isolation)
    - 트랜잭션이 실행되는 도중에 다른 트랜잭션의 영향을 받아 잘못된 결과를 만들어서는 안 됨
- 지속성(durability)
    - 트랜잭션이 성공적으로 수행되면 그 트랜잭션이 갱신한 데이터베이스의 내용은 영구적으로 저장됨

트랜잭션이 시작된 이후 COMMIT, ROLLBACK 이전의 데이터 상태는 다음과 같다.  

- 메모리 BUFFER에만 영향을 받았기 때문에 데이터의 변경 이전 상태로 복구 가능
- 현재 사용자는 `SELECT` 명령어로 결과 확인 가능
- 다른 사용자는 현재 사용자가 수행한 명령의 결과를 볼 수 없음
- 변경된 행은 잠금(LOCKING)이 설정되어 다른 사용자가 변경할 수 없음

COMMIT과 ROLLBACK을 사용함으로써 다음과 같은 효과를 볼 수 있다.  

- 데이터 무결성 보장
- 영구적인 변경을 하기 전에 데이터의 변경 사항 확인 가능
- 논리적으로 연관된 작업을 그룹핑하여 처리 가능


❗ Oracle의 경우 DBMS가 트랜잭션을 내부적으로 실행하며 사용자가 COMMIT 혹은 ROLLBACK을 수행해 주어야 트랜잭션이 종료되지만, MSSQL의 경우 기본적으로 AUTO COMMIT 모드이기 때문에 COMMIT과 ROLLBACK을 사용하려면 암시적/명시적 트랜잭션을 설정해야 한다.  
{:.note title='attention'}

### 4-2. COMMIT

트랜잭션을 완료한다. SQL문에 문제가 없다고 판단될 경우에 사용한다.  

```sql
COMMIT;
```

### 4-3. ROLLBACK

DML 명령어로 인한 테이블의 변경을 취소한다.  

```sql
ROLLBACK;
```

### 4-4. SAVEPOINT

저장점(SAVEPOINT)을 정의하면 롤백(ROLLBACK)할 때 트랜잭션을 SAVEPOINT까지의 일부만 롤백할 수 있다. 앞선 시점의 저장점으로 한번 롤백하면, 그 저장점 이후에 설정한 저장점이 무효가 된다.  

```sql
-- Oracle
SAVEPOINT [SAVE_NAME];

ROLLBACK TO [SAVE_NAME];

-- MSSQL
SAVE TRANSACTION [SAVE_NAME];

ROLLBACK TRANSACTION [SAVE_NAME];
```

---
## Reference
- [관계형 데이터베이스 개요](https://dataonair.or.kr/db-tech-reference/d-guide/sql/?pageid=4&mod=document&uid=337)
- [DDL](https://dataonair.or.kr/db-tech-reference/d-guide/sql/?pageid=4&mod=document&uid=338)
- [DML](https://dataonair.or.kr/db-tech-reference/d-guide/sql/?pageid=4&mod=document&uid=339)
- [TCL](https://dataonair.or.kr/db-tech-reference/d-guide/sql/?pageid=4&mod=document&uid=340)